
import sbt._
import Keys.baseDirectory
import scala.sys.process.Process


object JrrtTasks extends Build {


  val puckSvnDir = settingKey[File]("Location puck svn directory")

  val jrrtHome = settingKey[File]("Jrrt build directory")

  val jrrtReadOnly = settingKey[File]("jrrt-read-only directory")

  val java14frontend = settingKey[File]("Java1.4Frontend directory")

  val java15frontend = settingKey[File]("Java1.5Frontend directory")

  val controlFlowGraph = settingKey[File]("ControlFlowGraph directory")

  val java15comply = settingKey[Boolean]("will produce parser and scanner for java1.5 ")

  val jastaddSrcDir = settingKey[File]("Location of puck jrag files")
  val jastaddOutDir = settingKey[File]("Directory where are put sources generated by jastadd")

  /*
    Tasks
   */

  val jastadd = taskKey[Unit]("use ast, jrag and jadd files to generates java")

  val parser14 = taskKey[Unit]("create java 1.4 parser")
  val scanner14 = taskKey[Unit]("create java 1.4 scanner")

/*
  val gen = taskKey[Unit]("generates parser, scanner and AST files")
*/


  def concat(target: File, files : Seq[File]): Unit ={
    IO.delete(target) // delete from previous runs if clean wasn't called
    IO.touch(target)
    for (f <- files) {
      val content = IO.read(f)
      IO.append(target, content)
    }
  }

  lazy val root =
	    Project(id = "PuckConstraintSolver", base = file("."))
	      .settings(

        parser14 := {
          (jastaddOutDir.value / "parser").mkdirs()
          val parserAll = jastaddOutDir.value / "parser" / "JavaParser.all"
          /* generate the parser phase 1, create a full .lalr specification from fragments */

          val java15Files = if(java15comply.value)
            (PathFinder(java15frontend.value) * "*.parser").get
            else
          Seq()


          concat(parserAll,
          	Seq(jrrtReadOnly.value / "util" / "preamble.parser",
          		java14frontend.value / "parser" / "java14.parser",
          		java14frontend.value / "parser" / "errorrecovery.parser" ) ++ java15Files )

          /* generate the parser phase 2, translating .lalr to .beaver */
          val jastAddPaserJar = baseDirectory.value / "lib" / "JastAddParser.jar"
          val beaverRtJar = baseDirectory.value / "lib" / "beaver-rt-0.9.11.jar"
          val javaParserBeaver = jastaddOutDir.value / "parser" / "JavaParser.beaver"
          Process(Seq("java", "-cp", jastAddPaserJar.getPath + ":" + beaverRtJar.getPath,
            "Main", parserAll.getPath,  javaParserBeaver.getPath) ).!

          val beaverAnt = baseDirectory.value / "lib" / "beaver-cc-0.9.11.jar"

          /* generate the parser phase 3, translating .beaver to .java */
          Process(Seq("java", "-jar",  beaverAnt.getPath, "-T", "-w", javaParserBeaver.getPath )).!
        },

      scanner14 := {
        val scannerFlex = jastaddOutDir.value / "scanner" / "JavaScanner.flex"



        val files = if(java15comply.value)
          Seq(jrrtReadOnly.value / "util" / "preamble.flex",
            java14frontend.value / "scanner" / "macros.flex",
            java15frontend.value / "java15macros.flex",
            java14frontend.value / "scanner" / "rules_preamble.flex",

            jrrtReadOnly.value / "util" / "WhiteSpace.flex",
            jrrtReadOnly.value / "util" / "Comments.flex",
            java14frontend.value / "scanner" / "Keywords.flex",
            java15frontend.value / "java15keywords.flex",

            java14frontend.value / "scanner" / "Literals.flex",
            java15frontend.value / "java15literals.flex",

            java14frontend.value / "scanner" / "Separators.flex",
            java14frontend.value / "scanner" / "Operators.flex",
            java15frontend.value / "java15operators.flex",
            java15frontend.value / "java15identifiers.flex",

            java14frontend.value / "scanner" / "postamble.flex")
          else
          Seq(jrrtReadOnly.value / "util" / "preamble.flex",
            java14frontend.value / "scanner" / "macros.flex",
            java14frontend.value / "scanner" / "rules_preamble.flex",
            jrrtReadOnly.value / "util" / "WhiteSpace.flex",
            jrrtReadOnly.value / "util" / "Comments.flex",
            java14frontend.value / "scanner" / "Keywords.flex",
            java14frontend.value / "scanner" / "Literals.flex",
            java14frontend.value / "scanner" / "Separators.flex",
            java14frontend.value / "scanner" / "Operators.flex",
            java14frontend.value / "scanner" / "Identifiers.flex",
            java14frontend.value / "scanner" / "postamble.flex")

        concat(scannerFlex, files)

        val jflexJar = baseDirectory.value / "lib" / "jflex-1.6.0.jar"
        Process(Seq ("java", "-jar", jflexJar.getPath,
          "-d", (jastaddOutDir.value / "scanner").getPath,
          scannerFlex.getPath  //nobak="yes" option ?
        ))
        IO.copyFile(java14frontend.value / "scanner" / "Unicode.java",
          jastaddOutDir.value / "scanner" / "Unicode.java",
          preserveLastModified = true)
      },

	    jastadd := {

          val java14Files : PathFinder = java14frontend.value ** ("*.jrag" | "*.jadd" | "*.ast") filter
            {f : File => f.name match {
              case "BytecodeAttributes.jrag"
                | "BytecodeDescriptor.jrag"
                | "BytecodeReader.jrag" => false
              case _ => true
            }}

          val java15Files : PathFinder = java15frontend.value ** ("*.jrag" | "*.jadd" | "*.ast")

          val cfgFiles : PathFinder = Seq( controlFlowGraph.value / "Nodes.ast",
            controlFlowGraph.value / "ControlFlowGraph.jrag",
            controlFlowGraph.value / "Sets.jrag",
            controlFlowGraph.value / "Exceptions.jrag",
            controlFlowGraph.value / "Alias.jrag",
            controlFlowGraph.value / "ReachingDefinitions.jrag",
            controlFlowGraph.value / "DotGeneration.jrag" )

          val jrrtDir = jrrtReadOnly.value
          val jrrtFiles : PathFinder = (jrrtDir / "util") ** ("*.jrag" | "*.jadd" | "*.ast")

//          val jrrtFiles2 = (PathFinder(jrrtReadOnly.value ) ** (("*.jrag" | "*.jadd" | "*.ast") -- "util/*")).getPaths

          val jrrtFiles2 : PathFinder =
            jrrtDir ** ("*.ast" | "*.jrag" | "*.jadd") --- jrrtFiles ---
              Seq(jrrtDir / "tests" / "ProgramFactory.jrag",
                jrrtDir / "tests" / "RTXF.jrag",
                jrrtDir / "tests" / "Testing.jrag",
                jrrtDir / "undo" / "NoUndo.jrag",
                jrrtDir / "AccessibilityConstraints" / "SolverChoco.jrag",
                jrrtDir / "TypeConstraints" / "TypeConstraintSolving.jrag",
                jrrtDir / "TypeConstraints" / "CollectTypeConstraints.jrag",
                jrrtDir / "MakeMethodStatic" / "MakeMethodStatic.jrag",
                jrrtDir / "ChangeMethodSignature" / "ChangeParameterType.jrag")

          val puckFiles = PathFinder(jastaddSrcDir.value) ** ("*.jrag" | "*.jadd")

          val jrrtFiles3 : PathFinder = Seq(jrrtDir / "TypeConstraints" / "TypeConstraintSolving.jrag",
            jrrtDir / "TypeConstraints" / "CollectTypeConstraints.jrag")

          if (!jastaddOutDir.value.exists())
            jastaddOutDir.value.mkdirs()

          //TODO check how to use it directly !!
          val jastAddJar = baseDirectory.value / "lib" / "jastadd2.jar"
          Process("java" +: "-jar"
            +: jastAddJar.toString
            +: ("--o=" + jastaddOutDir.value)
            +: "--rewrite"
            +: "--beaver"
            +: "--novisitcheck"
            +: "--noCacheCycle"
            +: java14Files.getPaths
            ++: java15Files.getPaths
            ++: cfgFiles.getPaths
            ++: jrrtFiles.getPaths
            ++: jrrtFiles2.getPaths
            ++: puckFiles.getPaths
            ++: jrrtFiles3.getPaths).!
       /* java14Files.getPaths foreach println
        java15Files.getPaths foreach println
        cfgFiles.getPaths foreach println
        jrrtFiles.getPaths foreach println
        jrrtFiles2.getPaths foreach println
        puckFiles.getPaths foreach println
        jrrtFiles3.getPaths foreach println*/

       IO.copyDirectory(java14frontend.value / "beaver",
         jastaddOutDir.value / "beaver",
         preserveLastModified = true)
			}
		)

}