
import sbt._
import scala.sys.process.Process


object JrrtTasks extends Build {


  val puckSvnDir = settingKey[File]("Location puck svn directory")

  val jrrtHome = settingKey[File]("Jrrt build directory")

  val jrrtReadOnly = settingKey[File]("jrrt-read-only directory")

  val java14frontend = settingKey[File]("Java1.4Frontend directory")

  val java15frontend = settingKey[File]("Java1.5Frontend directory")

  val controlFlowGraph = settingKey[File]("ControlFlowGraph directory")


  val jastaddSrcDir = settingKey[File]("Location of puck jrag files")
  val jastaddOutDir = settingKey[File]("Directory where are put sources generated by jastadd")

  val jastadd = taskKey[Unit]("use ast, jrag and jadd files to generates java")


  val parser14 = taskKey[Unit]("create java 1.4 parser")

  def concat(files : Seq[File], target: File): Unit ={
    IO.delete(target) // delete from previous runs if clean wasn't called
    IO.touch(target)
    for (f <- files) {
      val content = IO.read(f)
      IO.append(target, content)
    }
  }

  lazy val root =
	    Project(id = "PuckConstraintSolver", base = file("."))
	      .settings(

        parser14 := {
          (jastaddOutDir.value / "parser").mkdirs()


        }

	    	jastadd := {

          val java14Files : PathFinder= (java14frontend.value) ** ("*.jrag" | "*.jadd" | "*.ast") filter
            {f : File => f.name match {
              case "BytecodeAttributes.jrag"
                | "BytecodeDescriptor.jrag"
                | "BytecodeReader.jrag" => false
              case _ => true
            }}

          val java15Files : PathFinder = (java15frontend.value) ** ("*.jrag" | "*.jadd" | "*.ast")

          val cfgFiles : PathFinder = Seq( controlFlowGraph.value / "Nodes.ast",
            controlFlowGraph.value / "ControlFlowGraph.jrag",
            controlFlowGraph.value / "Sets.jrag",
            controlFlowGraph.value / "Exceptions.jrag",
            controlFlowGraph.value / "Alias.jrag",
            controlFlowGraph.value / "ReachingDefinitions.jrag",
            controlFlowGraph.value / "DotGeneration.jrag" )

          val jrrtDir = jrrtReadOnly.value
          val jrrtFiles : PathFinder = (jrrtDir / "util") ** ("*.jrag" | "*.jadd" | "*.ast")

//          val jrrtFiles2 = (PathFinder(jrrtReadOnly.value ) ** (("*.jrag" | "*.jadd" | "*.ast") -- "util/*")).getPaths

          val jrrtFiles2 : PathFinder =
            jrrtDir ** ("*.ast" | "*.jrag" | "*.jadd") --- jrrtFiles ---
              Seq(jrrtDir / "tests" / "ProgramFactory.jrag",
                jrrtDir / "tests" / "RTXF.jrag",
                jrrtDir / "tests" / "Testing.jrag",
                jrrtDir / "undo" / "NoUndo.jrag",
                jrrtDir / "AccessibilityConstraints" / "SolverChoco.jrag",
                jrrtDir / "TypeConstraints" / "TypeConstraintSolving.jrag",
                jrrtDir / "TypeConstraints" / "CollectTypeConstraints.jrag",
                jrrtDir / "MakeMethodStatic" / "MakeMethodStatic.jrag",
                jrrtDir / "ChangeMethodSignature" / "ChangeParameterType.jrag")

          val puckFiles = PathFinder(jastaddSrcDir.value) ** ("*.jrag" | "*.jadd")

          val jrrtFiles3 : PathFinder = Seq(jrrtDir / "TypeConstraints" / "TypeConstraintSolving.jrag",
            jrrtDir / "TypeConstraints" / "CollectTypeConstraints.jrag")

          if (!jastaddOutDir.value.exists())
            jastaddOutDir.value.mkdirs()

          //TODO check how to use it directly !!
          val jastAddJar = Keys.baseDirectory.value / "project" / "lib" / "jastadd2.jar"
          Process("java" +: "-jar"
            +: jastAddJar.toString
            +: ("--o=" + jastaddOutDir.value)
            +: java14Files.getPaths
            ++: java15Files.getPaths
            ++: cfgFiles.getPaths
            ++: jrrtFiles.getPaths
            ++: jrrtFiles2.getPaths
            ++: puckFiles.getPaths
            ++: jrrtFiles3.getPaths).!
          //jastAdd.JastAddTask.main()
			}
		)

}