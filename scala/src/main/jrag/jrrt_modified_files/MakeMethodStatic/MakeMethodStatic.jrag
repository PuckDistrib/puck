aspect MakeMethodStatic {

    public MethodDecl MethodDecl.makeStatic() {
	if(isStatic())
	    return this;
	if(!fromSource() || !hasBlock())
	    throw new RefactoringException("cannot make static");
	programRoot().lockMethodNames(Collections.singleton(name()));
		
	MethodDecl newMethod = (MethodDecl)this.fullCopyAndDetach();
	TypeDecl hostType = hostType();
	// make new method static
	newMethod.getModifiers().addModifier(new Modifier("static"));
	// insert new method
	hostType.addBodyDecl(newMethod);
	// insert extra parameter
	String newParmName = hostType.name().toLowerCase();
	ParameterDeclaration newParm = new FreshParameter(hostType.createLockedAccess(), newParmName);
	newParm.setDemandFinal();
	newMethod.getParameterList().insertChild(newParm, 0);
	// fix type arguments
	newMethod = closeOverTypeVariables(newMethod);
	// fix body
	Access newParmAcc = newParm.createLockedAccess();
	WithStmt withStmt = new WithStmt(new List<Access>().add(newParmAcc), newMethod.getBlock());
	newMethod.setBlock(new Block(new List<Stmt>().add(withStmt)));
	newMethod.flushCaches();

	return newMethod;
    }

    public MethodDecl MethodDecl.doMakeStatic(boolean replace){

	MethodDecl newMethod = makeStatic();

	if(replace){

	    for(MethodAccess ma : uses()){

		if(!ma.fromSource()){
		    throw new RefactoringException("can't do replacement out of sources");
		}
			  
		List<Expr> args;

		args = new List<Expr>();
		if(ma.getQualifier() == null)
		    args.add(new ThisAccess());
		else	
		    args.add(ma.getQualifier());
		for(int i=0; i<ma.getArgs().numChildren(); i++){
		    args.add(ma.getArg(i));
		}

		if(ma.getParent() instanceof AbstractDot){
		    AbstractDot ad = (AbstractDot) ma.getParent();
		    ad.rotateLeft();
		    ad.replaceWith(newMethod.createLockedAccess(args));
		}
		else
		    ma.replaceWith(newMethod.createLockedAccess(args));
	    }
	    newMethod.programRoot().flushCaches();
	    removeMethod();
	}
	else{
	    // prepare delegating method
	    List<Expr> delegationArgs = new List<Expr>().add(new ThisAccess("this"));
	    for(int i=1;i<newMethod.getNumParameter();++i)
		delegationArgs.add(new VarAccess(newMethod.getParameter(i).name()));
	    Expr delegationCall = new MethodAccess(newMethod.name(), delegationArgs);
	    this.setBlock(new Block(new List<Stmt>().add(new ReturnStmt(delegationCall))));
	    // plug in delegating method
	}
	newMethod.programRoot().flushCaches();
	newMethod.programRoot().eliminate(RETURN_VOID, FRESH_VARIABLES, WITH_STMT, LOCKED_NAMES, DEMAND_FINAL_MODIFIER);
	return newMethod;
    }	

    MethodDecl MethodDecl.closeOverTypeVariables(MethodDecl newMethod) {
	if(newMethod.usesForeignTypeVars()) {
	    newMethod = newMethod.makeGeneric();
	    for(TypeVariable tv : newMethod.usedTypeVars()) {
		if(!tv.isDescendantTo(newMethod)) {
		    TypeVariable new_tv = (TypeVariable)tv.fullCopyAndDetach();
		    ((GenericMethodDecl)newMethod).addTypeParameter(new_tv);
		    for(Access tvu : tv.uses())
			if(tvu.isDescendantTo(newMethod))
			    ((TypeAccess)tvu).lock(new_tv);				
		}
	    }
	}
	return newMethod;
    }
	
    GenericMethodDecl MethodDecl.makeGeneric() {
	GenericMethodDecl g = new GenericMethodDecl(getModifiers(), getTypeAccess(), getID(), 
						    getParameterList(), getExceptionList(), 
						    getBlockOpt(), new List<TypeVariable>());
	replaceWith(g);
	return g;
    }
	
    GenericMethodDecl GenericMethodDecl.makeGeneric() {
	return this;
    }
}