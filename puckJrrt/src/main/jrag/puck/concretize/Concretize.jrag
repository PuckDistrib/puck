import puck.PuckError;

aspect Concretize {


    eq ExprPlaceHolder.type() = getTypeDecl();

    syn boolean Expr.isEmptyReceiver();
    eq Expr.isEmptyReceiver() = false;
    eq EmptyReceiver.isEmptyReceiver() = true;

    syn boolean Expr.isDummyConstructorCall();
    eq Expr.isDummyConstructorCall() = false;
    eq DummyConstructorCall.isDummyConstructorCall() = true;

    public void DummyConstructorCall.prettyPrint(PrettyPrinter out){
        out.print("/* DummyConstructorCall */");
    }
    public void EmptyReceiver.prettyPrint(PrettyPrinter out){
        out.print("/* EmptyReceiver */");
    }


    public void ASTNode.replaceConstructorCall(ConstructorDecl oldUsed, ConstructorDecl newUsed){
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).replaceConstructorCall(oldUsed, newUsed);
    }

    public void ClassInstanceExpr.replaceConstructorCall(ConstructorDecl oldUsed, ConstructorDecl newUsed){
        if(this.decl() == oldUsed){
            setAccess(newUsed.hostType().createLockedAccess());
            setTarget(newUsed);
        }
    }




    public String CompilationUnit.getRootPath(){
        String packagePath = packageName().replaceAll("\\.", File.separator);
//        System.out.println("packagePath : " + packagePath);
        int idx = pathName().indexOf(packagePath);
        if(idx != -1)
            return pathName().substring(0, idx-1);
        else {
            //if the compilation unit path does not match the package it is contained in
            // we define the folder containing it as the root
            idx = pathName().lastIndexOf(File.separatorChar);
            return pathName().substring(0, idx -1);
        }
    }

    public void	CompilationUnit.setPathName(String path){
        SourceFilePath sfp = new SourceFilePath(path);
        setClassSource(new FileClassSource(sfp, sfp.getPath()));
    }

    public void Program.printCodeInDirectory(File dir) throws IOException {

        for(CompilationUnit cu : getCompilationUnits()){

            if(cu.fromSource()) {
                String relativePath = cu.getPackageDecl().replace('.', File.separatorChar);

                File originalPath = new File(cu.pathName());
                File f = new File(dir + File.separator +
                    relativePath + File.separator + originalPath.getName());

                f.getParentFile().mkdirs();
                BufferedWriter writer = new BufferedWriter(new FileWriter(f));
                writer.write(cu.prettyPrint());
                writer.close();
            }
        }
    }


    public String Program.getRootPath(){
        CompilationUnit rcu = getCompilationUnit(0);
        int i = 0;
        while(rcu == null && i < getNumCompilationUnit()){
            i++;
            rcu = getCompilationUnit(i);
        }

        if(rcu == null) throw new Error("cannot found rootPath");

        return rcu.getRootPath();
    }

    public void Program.eliminateLockedNamesInSources(){
        //calling eliminateLockedNames from program after calling lockAllNames
        //provoke cause exceptions in the "@primitive package"
        for (CompilationUnit cu : (List<CompilationUnit>)getCompilationUnitList()){
            if(cu.fromSource())
                cu.eliminateLockedNamesInSubtree();
        }
    }
}