import puck.PuckError;

aspect Concretize {


    eq ExprPlaceHolder.type() = getTypeDecl();

    syn boolean Expr.isEmptyReceiver();
    eq Expr.isEmptyReceiver() = false;
    eq EmptyReceiver.isEmptyReceiver() = true;

    syn boolean Expr.isDummyConstructorCall();
    eq Expr.isDummyConstructorCall() = false;
    eq DummyConstructorCall.isDummyConstructorCall() = true;

    public void DummyConstructorCall.prettyPrint(PrettyPrinter out){
        out.print("/* DummyConstructorCall */");
    }
    public void EmptyReceiver.prettyPrint(PrettyPrinter out){
        out.print("/* EmptyReceiver */");
    }


    public String CompilationUnit.getRootPath(){
        String packagePath = packageName().replaceAll("\\.", File.separator);
//        System.out.println("packagePath : " + packagePath);
        int idx = pathName().indexOf(packagePath);
        if(idx != -1)
            return pathName().substring(0, idx-1);
        else {
            //if the compilation unit path does not match the package it is contained in
            // we define the folder containing it as the root
            idx = pathName().lastIndexOf(File.separatorChar);
            return pathName().substring(0, idx -1);
        }
    }

    public void	CompilationUnit.setPathName(String path){
        SourceFilePath sfp = new SourceFilePath(path);
        setClassSource(new FileClassSource(sfp, sfp.getPath()));
    }

    public void Program.printCodeInDirectory(File dir) throws IOException {

        for(CompilationUnit cu : getCompilationUnits()){

            if(cu.fromSource()) {
                String relativePath = cu.getPackageDecl().replace('.', File.separatorChar);

                File originalPath = new File(cu.pathName());
                File f = new File(dir + File.separator +
                    relativePath + File.separator + originalPath.getName());

                f.getParentFile().mkdirs();
                BufferedWriter writer = new BufferedWriter(new FileWriter(f));
                writer.write(cu.prettyPrint());
                writer.close();
            }
        }
    }


    public String Program.getRootPath(){
        CompilationUnit rcu = getCompilationUnit(0);
        int i = 0;
        while(rcu == null && i < getNumCompilationUnit()){
            i++;
            rcu = getCompilationUnit(i);
        }

        if(rcu == null) throw new Error("cannot found rootPath");

        return rcu.getRootPath();
    }

    public Program Program.program() { return this;}
//    public void Program.eliminateLockedNamesInSources(){
//        //calling eliminateLockedNames from program after calling lockAllNames
//        //provoke cause exceptions in the "@primitive package"
//        for (CompilationUnit cu : getCompilationUnitList()){
//            if(cu.fromSource())
//                cu.eliminateLockedNamesInSubtree();
//        }
//    }

    public void Program.flushLibraryTypesTreeCache(){
        for(TypeDecl td : libraryTypeMap.values()){
        td.flushTreeCache();
        }
    }
    public void Program.resetPrimitiveTypes() {
        //initializeLibraryTypeMap();
        PrimitiveCompilationUnit unit = getPrimitiveCompilationUnit();
        TypeDecl t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".boolean");
        unit.typeBoolean_computed = true;
        unit.typeBoolean_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".byte");
        unit.typeByte_computed = true;
        unit.typeByte_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".short");
        unit.typeShort_computed = true;
        unit.typeShort_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".char");
        unit.typeChar_computed = true;
        unit.typeChar_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".int");
        unit.typeInt_computed = true;
        unit.typeInt_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".long");
        unit.typeLong_computed = true;
        unit.typeLong_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".float");
        unit.typeFloat_computed = true;
        unit.typeFloat_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".double");
        unit.typeDouble_computed = true;
        unit.typeDouble_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".null");
        unit.typeNull_computed = true;
        unit.typeNull_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".void");
        unit.typeVoid_computed = true;
        unit.typeVoid_value = t;

        t = libraryTypeMap.get(PRIMITIVE_PACKAGE_NAME + ".Unknown");
        unit.unknownType_computed = true;
        unit.unknownType_value = t;
    }
}