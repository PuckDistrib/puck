/*
 * Puck is a dependency analysis and refactoring tool.
 * Copyright (C) 2016 Loïc Girault loic.girault@gmail.com
 *               2016 Mikal Ziane  mikal.ziane@lip6.fr
 *               2016 Cédric Besse cedric.besse@lip6.fr
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Additional Terms.
 * Author attributions in that material or in the Appropriate Legal
 * Notices displayed by works containing it is required.
 *
 * Author of this file : Loïc Girault
 */

aspect TypeUser {

    interface TypeMember {
        TypeDecl hostType();
        String name();
        boolean isStatic();
    }

    Variable extends TypeMember;
    MethodDecl implements TypeMember;

    interface TypeMemberAccess{

        TypeDecl type(); //return type of method or type of field

        int buildDGNode(JastaddGraphBuilder builder);

        boolean isQualified();
        Expr qualifier();

        TypeMember decl();

        BodyDecl hostBodyDecl();

        TypeDecl hostType();
    }
    VarAccess implements TypeMemberAccess;
    MethodAccess implements TypeMemberAccess;


      public interface PotentialStaticDeclAccess{
        ASTNode lock();
        boolean isDeclStatic();
    }

    TypeMemberAccess extends PotentialStaticDeclAccess;
    ConstructorAccess implements PotentialStaticDeclAccess;

    public boolean ConstructorAccess.isDeclStatic() {
        return true;
    }

    public boolean VarAccess.isDeclStatic() {
        return decl().isStatic();
    }

    public boolean MethodAccess.isDeclStatic() {
        return decl().isStatic();
    }

	class NoTypeUser extends Error {
        public NoTypeUser(){}
        public NoTypeUser(String msg){
            super(msg);
        }
    }


    void Expr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        throw new DGBuildingError(this.prettyPrint() + "(" +this.getClass() + ") in " +
                this.compilationUnit().pathName() +" line " +
                this.location() + " typeUser not found");
    }

    void Expr.bindTypeUse(JastaddGraphBuilder builder, int thisDGId, Uses typeMemberUse){
        builder.bindTypeUse(thisDGId, type(), typeMemberUse);
    }
    // findTypeUserAndBindUses rec calls

    void AssignExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getDest().findTypeUserAndBindUses(builder, typeMemberUse);
    }

    void Dot.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        if(isRightRotated())
            rotateLeft();
        getRight().findTypeUserAndBindUses(builder, typeMemberUse);
    }

    void ParExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }
    void ArrayAccess.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        prevExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }
    void ConditionalExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getFalseExpr().findTypeUserAndBindUses(builder, typeMemberUse);
        getTrueExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }


    // findTypeUserAndBindUses term cases


    void AddExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){  System.out.println("AddExpr.typeUserFromLeftExpr(builder)");
        System.out.println("=this.hostBodyDecl().buildDGNode(builder)");
        System.out.println("to check");
        bindTypeUse(builder, this.hostBodyDecl().buildDGNode(builder), typeMemberUse);
    }

    void CastExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        bindTypeUse(builder, getTypeAccess().buildDGNode(builder), typeMemberUse);
    }

    void Literal.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        bindTypeUse(builder, type().buildDGNode(builder), typeMemberUse);
    }


    // findTypeUserAndBindUses term cases - Access subclasses

    void Access.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        if(accessed() instanceof TypeMemberSubstitute)
            builder.findTypeUserAndBindUses(typeMemberUse, this, (TypeMemberSubstitute) accessed());
        else
            bindTypeUse(builder, this.buildDGNode(builder), typeMemberUse);
    }

    void ClassInstanceExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        super.findTypeUserAndBindUses(builder, typeMemberUse);
        if(hasTypeDecl())
            setTarget(null);
    }

    void VarAccess.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        super.findTypeUserAndBindUses(builder, typeMemberUse);
        // do not lock varAccess
        setTargetVariable(null);
    }

    public TypeDecl TypeMemberSubstitute.getOriginalType(){
        return getOriginal().type();
    }


}