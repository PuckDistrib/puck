/*
 * Puck is a dependency analysis and refactoring tool.
 * Copyright (C) 2016 Loïc Girault loic.girault@gmail.com
 *               2016 Mikal Ziane  mikal.ziane@lip6.fr
 *               2016 Cédric Besse cedric.besse@lip6.fr
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Additional Terms.
 * Author attributions in that material or in the Appropriate Legal
 * Notices displayed by works containing it is required.
 *
 * Author of this file : Loïc Girault
 */

aspect TypeUser {

    interface TypeMember {
        TypeDecl hostType();
        String name();
        boolean isStatic();
    }

    Variable extends TypeMember;
    MethodDecl implements TypeMember;

    interface TypeMemberAccess{
        int buildDGNode(JastaddGraphBuilder builder);

        Expr getQualifier();

        TypeMember decl();

        BodyDecl hostBodyDecl();

        TypeDecl hostType();
    }
    VarAccess implements TypeMemberAccess;
    MethodAccess implements TypeMemberAccess;


      public interface PotentialStaticDeclAccess{
        ASTNode lock();
        boolean isDeclStatic();
    }

    TypeMemberAccess extends PotentialStaticDeclAccess;
    ConstructorAccess implements PotentialStaticDeclAccess;

    public boolean ConstructorAccess.isDeclStatic() {
        return true;
    }

    public boolean VarAccess.isDeclStatic() {
        return decl().isStatic();
    }

    public boolean MethodAccess.isDeclStatic() {
        return decl().isStatic();
    }

	class NoTypeUser extends Error {
        public NoTypeUser(){}
        public NoTypeUser(String msg){
            super(msg);
        }
    }



    public void Access.buildTypeUseFromLeftExpr(JastaddGraphBuilder builder, Uses typeMemberUse){
        Expr lexpr = getLeftExpr();

        if(lexpr == null)
            throw new NoTypeUser(this+"("+this.getClass()+") in "+this.compilationUnit().pathName()+" "+this.location());
        else
            lexpr.findTypeUserAndBindUses(builder, typeMemberUse);

    }

    void Expr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        throw new DGBuildingError(this + "(" +this.getClass() + ") in " +
                this.compilationUnit().pathName() +" line " +
                this.location() + " typeUser not found");
    }
//    Uses Expr.bindTypeUse(JastaddGraphBuilder builder, int thisDGId, Uses typeMemberUse){
//        return builder.bindTypeUse(thisDGId, type().buildDGNode(builder), typeMemberUse);
//    }
    void Expr.bindTypeUse(JastaddGraphBuilder builder, int thisDGId, Uses typeMemberUse){
        builder.bindTypeUse(thisDGId, type(), typeMemberUse);
    }
    // findTypeUserAndBindUses rec calls

    void AssignExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getDest().findTypeUserAndBindUses(builder, typeMemberUse);
    }

    void Dot.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        if(isRightRotated())
            rotateLeft();
        getRight().findTypeUserAndBindUses(builder, typeMemberUse);
    }

    void ParExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }
    void ArrayAccess.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getLeftExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }
    void ConditionalExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        getFalseExpr().findTypeUserAndBindUses(builder, typeMemberUse);
        getTrueExpr().findTypeUserAndBindUses(builder, typeMemberUse);
    }


    // findTypeUserAndBindUses term cases


    void AddExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){  System.out.println("AddExpr.typeUserFromLeftExpr(builder)");
        System.out.println("=this.hostBodyDecl().buildDGNode(builder)");
        System.out.println("to check");
        bindTypeUse(builder, this.hostBodyDecl().buildDGNode(builder), typeMemberUse);
    }

    void CastExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        bindTypeUse(builder, getTypeAccess().buildDGNode(builder), typeMemberUse);
    }

    void Literal.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        bindTypeUse(builder, type().buildDGNode(builder), typeMemberUse);
    }


    // findTypeUserAndBindUses term cases - Access subclasses

    void Access.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        if(accessed() instanceof TypeMemberSubstitute)
            findTypeUserAndBindUses(builder, typeMemberUse, (TypeMemberSubstitute) accessed());
        else
            bindTypeUse(builder, this.buildDGNode(builder), typeMemberUse);
    }


    void Access.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse, TypeMemberSubstitute substitute){
        if(substitute.getOriginalType() instanceof TypeVariable){
            TypeVariable tv= (TypeVariable)substitute.getOriginalType();
            if(tv.owner() instanceof GenericTypeDecl)
                findTypeVariableInstanciatorAndBindUsesInLeftExpr(builder, substitute.type(),
                        tv, typeMemberUse);
            else
                System.out.println("Access.findTypeUserAndBindUses tv.owner() " +
                        "not instanceof GenericTypeDecl : TODO !!!");

        }
        else if( substitute.getOriginalType() instanceof ParTypeDecl
                || type() instanceof ParTypeDecl ){
            System.out.println("Access.findTypeUserAndBindUses substitute.getOriginalType()  " +
                    "instanceof ParTypeDecl : TODO !!!");
        }
        else if(type().instanceOf(substitute.getOriginalType()))
            bindTypeUse(builder, this.buildDGNode(builder), typeMemberUse);
        else
            mandatoryAssert(false);
    }

    void Access.constraintTypeUses(JastaddGraphBuilder builder,
                                   int otherTypeUser,
                                   ParTypeDecl lValueType){
        if(! (this.type() instanceof  ParTypeDecl) )
            System.out.println("Access.constraintTypeUses this.type() " +
                    "not instanceof ParTypeDecl  : TODO !!!");

        ParTypeDecl rValueType = (ParTypeDecl) this.type();
        if(rValueType.numTypeParameter() != lValueType.numTypeParameter())
            System.out.println("Access.constraintTypeUses " +
                    "rValueType.getNumArgument() != lValueType.getNumArgument()  : TODO !!!");

        //Hypothesis : argument are in same order  C<B,A> extends I<A,B> kind of case not handled
        int thisNodeId = this.buildDGNode(builder);
        builder.addTypeUsesConstraint(thisNodeId, rValueType.genericDecl().buildDGNode(builder) ,
                otherTypeUser, lValueType.genericDecl().buildDGNode(builder));

        for(int i =0; i<lValueType.numTypeParameter(); i++) {
            TypeDecl lValueArg = lValueType.getParameterization().getArg(i);
            TypeDecl rValueArg = rValueType.getParameterization().getArg(i);
            if(lValueArg instanceof WildcardType || rValueArg instanceof WildcardType)
                continue;

            if(rValueArg instanceof TypeVariable)
                findTypeVariableInstanciatorAndBindUses(builder,
                        lValueArg,
                        (TypeVariable)rValueArg,
                        new Uses(otherTypeUser, rValueArg.buildDGNode(builder), UsesAccessKind.none()));
            else
                builder.addTypeUsesConstraint(thisNodeId, rValueArg.buildDGNode(builder),
                        otherTypeUser, lValueArg.buildDGNode(builder));
        }

    }


    void ClassInstanceExpr.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        super.findTypeUserAndBindUses(builder, typeMemberUse);
        if(hasTypeDecl())
            setTarget(null);
    }

    void VarAccess.findTypeUserAndBindUses(JastaddGraphBuilder builder, Uses typeMemberUse){
        super.findTypeUserAndBindUses(builder, typeMemberUse);
        // do not lock varAccess
        setTargetVariable(null);
    }

    void Access.findTypeVariableInstanciatorAndBindUsesInLeftExpr(JastaddGraphBuilder builder,
                                                           TypeDecl typeUsed,
                                                           TypeVariable tv,
                                                           Uses typeMemberUse) {
        Expr lexpr = getLeftExpr();
        if (lexpr == null)
            throw new NoTypeUser(this + "(" + this.getClass() + ") in " + this.compilationUnit().pathName() + " " + this.location());
        else
            lexpr.findTypeVariableInstanciatorAndBindUses(builder, typeUsed, tv, typeMemberUse);

    }

    void Expr.findTypeVariableInstanciatorAndBindUses(JastaddGraphBuilder builder,
                                                 TypeDecl typeUsed,
                                                 TypeVariable tv,
                                                 Uses typeMemberUse){
        System.out.println(this.getClass()+".findTypeVariableInstanciatorAndBindUses : TODO !!!");
    }


    void Access.findTypeVariableInstanciatorAndBindUses(JastaddGraphBuilder builder,
                                                 TypeDecl typeUsed,
                                                 TypeVariable tv,
                                                 Uses typeMemberUse){
        if(this.type() instanceof ParTypeDecl){
            GenericElement ge = (GenericElement) ((ParTypeDecl) this.type()).genericDecl();
            if(ge.ownTypeVariable(tv))
                builder.bindTypeUse(this.buildDGNode(builder), typeUsed, typeMemberUse);
            else
                System.out.println("Access.findTypeVariableInstanciatorAndBindUses " +
                        "not ge.ownTypeVariable(tv) : TODO !!!");
        }
        else
            findTypeVariableInstanciatorAndBindUsesInLeftExpr(builder, typeUsed, tv, typeMemberUse);

    }

    public TypeDecl TypeMemberSubstitute.getOriginalType(){
        return getOriginal().type();
    }


}