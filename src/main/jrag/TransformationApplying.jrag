
aspect TransformationApplying {
	
      public String CompilationUnit.getRootPath(){
        String packagePath = packageName().replaceAll("\\.", File.separator);
//        System.out.println("packagePath : " + packagePath);
        int idx = pathName().indexOf(packagePath);
        if(idx != -1)
            return pathName().substring(0, idx-1);
        else {
            //if the compilation unit path does not match the package it is contained in
            // we define the folder containing it as the root
            idx = pathName().lastIndexOf(File.separatorChar);
            return pathName().substring(0, idx -1);
        }
    }

    public void CompilationUnit.removeTypeDecl(TypeDecl td){
        String name = td.name();
        int idx =  getTypeDeclList().getIndexOfChild(td);
        if(idx != -1) {
            getTypeDeclList().removeChild(idx);

            if (pathName().endsWith(name + ".java")) {
                for (int i = 0; i < getNumTypeDecl(); i++) {
                    TypeDecl td2 = getTypeDecl(i);
                    if (td != td2) { //sanity check
                        String newPath = pathName.replace(name + ".java", td2.name() + ".java");
                        this.setPathName(newPath);
                    }
                }
            }
        }
    }

    public void ClassDecl.removeImplements(InterfaceDecl decl) {
          int idx = -1;
          for(int i = 0; i < getImplementsList().getNumChild(); i++){
              if(((TypeAccess)getImplements(i)).decl().equals(decl)){
                  idx = i;
              }
          }
          if(idx!= -1)
              getImplementsList().removeChild(idx);
      }

    public void InterfaceDecl.removeSuperInterface(InterfaceDecl decl) {
           int idx = -1;
           for(int i = 0; i < getSuperInterfaceIdList().getNumChild(); i++){
               if(((TypeAccess)getSuperInterfaceId(i)).decl().equals(decl)){
                   idx = i;
               }
           }
           if(idx!= -1)
               getSuperInterfaceIdList().removeChild(idx);
       }

  void TypeDecl.replaceTypeAccessInList(Access oldAccess, Access newAccess, List<Access> list){
    if(!oldAccess.isTypeAccess() || !newAccess.isTypeAccess())
      throw new Error("Both access should be type access !");
    TypeDecl oldDecl = ((TypeAccess)oldAccess).decl();
    TypeDecl newDecl = ((TypeAccess)newAccess).decl();

    boolean containsNewAccess = false;
    Access oldAccess0 = null;

    for(Access acc : list){
      if(((TypeAccess)acc).decl().equals(newDecl))
        containsNewAccess = true;

      if(((TypeAccess)acc).decl().equals(oldDecl))
        oldAccess0 = acc;
    }

    if(containsNewAccess)
      list.removeChild(oldAccess0);
    else
      replace(oldAccess0).with(newAccess);

  }

 public void ClassDecl.replaceImplements(Access oldAccess, Access newAccess){
       replaceTypeAccessInList(oldAccess, newAccess, getImplementsList());
  }

 public void InterfaceDecl.replaceSuperInterface(Access oldAccess, Access newAccess){
    replaceTypeAccessInList(oldAccess, newAccess, getSuperInterfaceIds());
  }


  public void Program.printCodeInDirectory(File dir) throws IOException {

    for(CompilationUnit cu : getCompilationUnits()){

      if(cu.fromSource()) {
        String relativePath = cu.getPackageDecl().replace('.', File.separatorChar);

        File f = new File(dir + File.separator +
          relativePath + File.separator + cu.getID() + ".java");

        f.getParentFile().mkdirs();
        BufferedWriter writer = new BufferedWriter(new FileWriter(f));
        writer.write(cu.toString());
        writer.close();
      }
    }
  }

	//scala compiler does not like ASTNode type parameter bound
	public CompilationUnit Program.insertUnusedType(String path, String pkg, TypeDecl td) {
       return insertUnusedType(path, pkg, new List<ImportDecl>(), td);
    }

    public static MethodDecl MethodDecl.createAbstractMethod(Access returnType, String name, ParameterDeclaration[] params){
      List<ParameterDeclaration> paramList = new List<ParameterDeclaration>();
      for(ParameterDeclaration p : params){
          paramList.add(p);
      }
      return new MethodDecl(new Modifiers("public", "abstract"), returnType, name, paramList, new List<Access>(), new Opt());
  	}

  	public MethodDecl ConstructorDecl.createConstructorMethod(String name){                                                                               
         List<ParameterDeclaration> params = this.getParameterList().copy();                                                               
         List<Expr> args = new List<Expr>();                                                                                               
         for(int i =0; i< params.getNumChild(); i++)                                                                                       
             args.add(params.getChild(i).createLockedAccess());                                                                            
                                                                                                                                           
         return new MethodDecl(new Modifiers("public"),                                                                                    
                 this.hostType().createLockedAccess(),                                                                                     
                 name, params, new List<Access>(),                                                                                         
                 new Opt<Block>(new Block(new ReturnStmt( new ClassInstanceExpr(hostType().createLockedAccess(), args)))));                
                                                                                                                                           
     }                 
    

	public void ASTNode.replaceTypeAccess(Access oldUsee, Access newUsee){
      for(int i = 0; i < getNumChild(); i++)
          getChild(i).replaceTypeAccess(oldUsee, newUsee);
  	}

  	public void TypeAccess.replaceTypeAccess(Access oldUsee, Access newUsee){
        
        if( oldUsee.isTypeAccess()
                && this.decl().equals(((TypeAccess)oldUsee).decl())){
            replace(this).with(newUsee);
        }
    }
  //stop propagation
  public void ClassInstanceExpr.replaceTypeAccess(Access oldUsee, Access newUsee){

        /*System.out.println("****************************************************");
        System.out.println("****************************************************");
        System.out.println("****************************************************");
        System.out.println();


        System.out.println(this + " stop propagation of replaceTypeAccess("+oldUsee+", "+newUsee+")");
        System.out.println(" getAccess() instanceof ParTypeAccess = " + (getAccess() instanceof ParTypeAccess));
        for(int i=0; i<getNumChild(); i++){
            System.out.println("child "+ i + " : " + getChild(i).getClass() + " = " + getChild(i).getClass());

        }*/

        if( getAccess() instanceof ParTypeAccess){
            List<Access> typeArgs =  ((ParTypeAccess) getAccess()).getTypeArguments();
            for(int i = 0; i<typeArgs.getNumChild(); i++){
                typeArgs.getChild(i).replaceTypeAccess(oldUsee, newUsee);
            }
            //parTypeAccess.getTypeArguments().replaceTypeAccess(oldUsee, newUsee);
        }
        getArgList().replaceTypeAccess(oldUsee, newUsee);
        getTypeDeclOpt().replaceTypeAccess(oldUsee, newUsee);
    }


  public void ASTNode.replaceMethodCall(MethodDecl oldUsee, MethodDecl newUsee){
      for(int i = 0; i < getNumChild(); i++)
          getChild(i).replaceMethodCall(oldUsee, newUsee);
  } 

  public void MethodAccess.replaceMethodCall(MethodDecl oldUsee, MethodDecl newUsee){                                                                  
        if(this.decl() == oldUsee){                                                                                                         
                                                                                                                                            
            MethodAccessInfo mai = newUsee.hostType().accessMemberMethod(newUsee);                                                          
            //MethodAccessInfo mai = this.accessMethod(newUsee);                                                                            
                                                                                                                                            
            if(mai == null)                                                                                                                 
                System.out.println("mai is null !!");                                                                                       
                                                                                                                                            
            MethodAccess ma = mai.constructAccess(this, this.getArgList());                                                                 
                                                                                                                                            
            if(ma.getQualifier() == null) {                                                                                                 
                ParameterDeclaration p =                                                                                                    
                        ((MethodDecl) this.hostBodyDecl()).introduceParameter(newUsee.hostType(), "");                                      
                replace(this).with(new Dot(p.createLockedAccess(), ma));                                                                    
            }                                                                                                                               
            else                                                                                                                            
                replace(this).with(ma);                                                                                                     
        }                                                                                                                                   
    } 


  public void ASTNode.replaceByConstructorMethodCall(MethodDecl cm){
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).replaceByConstructorMethodCall(cm);
    }

  private int MethodDecl.uidSeed = 0;
  public ParameterDeclaration MethodDecl.introduceParameter(TypeDecl typeCreated, String suffix){
        //TODO make code ok for generic type !
        Collection<ConstructorDecl> ctors = typeCreated.constructors();
        ConstructorDecl noArgsCtor = null;
        for(ConstructorDecl ctor : ctors){
            if(ctor.getParameterList().getNumChild() == 0)
                noArgsCtor= ctor;
        }
        if(noArgsCtor == null)
            throw new Error("no parameterless constructor for class " + typeCreated.fullName());

        ParameterDeclaration newParameter =
                new ParameterDeclaration(new Modifiers(),
                        typeCreated.createLockedAccess(),
                        typeCreated.name().toLowerCase() + suffix + uidSeed);
        uidSeed ++;

        addParameter(newParameter);

        for(MethodAccess methodUse : uses())
            methodUse.addArg(new ClassInstanceExpr(typeCreated.createLockedAccess(),  new List<Expr>()));
            return newParameter;
    }
  
  public void ClassInstanceExpr.replaceByConstructorMethodCall(MethodDecl cm){
        if( !(this.hostBodyDecl() instanceof MethodDecl))
            throw new Error("replaceByConstructorMethodCall, this.hostBodyDecl is " +
                    this.hostBodyDecl().getClass() + "does not know what to do !!");

        MethodDecl enclosingMethod = (MethodDecl)this.hostBodyDecl();

        ParameterDeclaration factoryParameter =
                enclosingMethod.introduceParameter(((TypeAccess)this.getAccess()).decl(), "Ktor");

        replace(this).with(new Dot(factoryParameter.createLockedAccess(),
                cm.createBoundAccess(this.getArgs())));

    }

 

  public void ASTNode.puckDelete(){
         getParent().removeChild(this);
         this.setParent(null);
     }

  public void TypeDecl.puckDelete(){                                                                                                           
         if(compilationUnit().getNumTypeDecl() == 1)                                                                                       
             compilationUnit().puckDelete();                                                                                             
         else                                                                                                                              
             super.puckDelete();                                                                                                         
     }
 
}