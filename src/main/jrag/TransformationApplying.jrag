import puck.PuckError;

aspect TransformationApplying {

    public void ASTNode.replaceFieldAccess(FieldDeclaration oldUsed, Access newUsed) {
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).replaceFieldAccess(oldUsed, newUsed);
    }
    public void VarAccess.replaceFieldAccess(FieldDeclaration oldUsed, Access newUsed) {
        if(decl().equals(oldUsed)){
            replace(this).with(newUsed);
        }
    }

    public void ASTNode.replaceThisQualifierFor(MethodDecl method, Access byAccess){
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).replaceThisQualifierFor(method, byAccess);
    }

    public void MethodAccess.replaceThisQualifierFor(MethodDecl method, Access byAccess){
        if(this.decl() == method){
            if(getQualifier() == null || getQualifier().isThisAccess())
                replace(this).with(new Dot(byAccess, this));
            else
                replace(getQualifier()).with(byAccess);
        }
    }


  public void ASTNode.replaceConstructorCall(ConstructorDecl oldUsed, ConstructorDecl newUsed){
      for(int i = 0; i < getNumChild(); i++)
        getChild(i).replaceConstructorCall(oldUsed, newUsed);
  }

  public void ClassInstanceExpr.replaceConstructorCall(ConstructorDecl oldUsed, ConstructorDecl newUsed){
        if(this.decl() == oldUsed){
            setAccess(newUsed.hostType().createLockedAccess());
            setTarget(newUsed);
        }
  }

  public static ConstructorDecl ConstructorDecl.createConstructor(Access hostType,  String name, ParameterDeclaration[] params){
        List<ParameterDeclaration> paramList = new List<ParameterDeclaration>();
        for(ParameterDeclaration p : params){
            paramList.add(p);
        }

        /*String name = "";

        if(hostType instanceof ParTypeAccess){
            name = ((ParTypeAccess)hostType).name();
        }
        if(hostType instanceof TypeAccess){
            name = ((TypeAccess)hostType).name();
        }*/

        return new ConstructorDecl(new Modifiers("public"), name, paramList, new List<Access>(), new Opt(), new Block());
  }

  public void TypeDecl.removeSuperType(Access superTypeAccess){
        throw new PuckError("removeSuperType in " + this.getClass() +"not implemented");
  }

  public void ClassDecl.removeSuperType(Access superTypeAccess){
        if(getSuperClassAccess().equals(superTypeAccess)){
        setSuperClassAccessOpt(new Opt<Access>());
        return;
        }
        List<Access> implementsList =  getImplementsList();

        for(int i = 0; i< implementsList.getNumChild(); i++)
        if(implementsList.getChild(i).equals(superTypeAccess)){
        implementsList.removeChild(i);
        break;
        }
    }
      public String CompilationUnit.getRootPath(){
        String packagePath = packageName().replaceAll("\\.", File.separator);
//        System.out.println("packagePath : " + packagePath);
        int idx = pathName().indexOf(packagePath);
        if(idx != -1)
            return pathName().substring(0, idx-1);
        else {
            //if the compilation unit path does not match the package it is contained in
            // we define the folder containing it as the root
            idx = pathName().lastIndexOf(File.separatorChar);
            return pathName().substring(0, idx -1);
        }
    }

    public void CompilationUnit.removeTypeDecl(TypeDecl td){
        String name = td.name();
        int idx =  getTypeDeclList().getIndexOfChild(td);
        if(idx != -1) {
            getTypeDeclList().removeChild(idx);

            if (pathName().endsWith(name + ".java")) {
                for (int i = 0; i < getNumTypeDecl(); i++) {
                    TypeDecl td2 = getTypeDecl(i);
                    if (td != td2) { //sanity check
                        String newPath = pathName.replace(name + ".java", td2.name() + ".java");
                        this.setPathName(newPath);
                    }
                }
            }
        }
    }

    public void ClassDecl.removeImplements(InterfaceDecl decl) {
          int idx = -1;
          for(int i = 0; i < getImplementsList().getNumChild(); i++){
              if(((TypeAccess)getImplements(i)).decl().equals(decl)){
                  idx = i;
              }
          }
          if(idx!= -1)
              getImplementsList().removeChild(idx);
      }

    public void InterfaceDecl.removeSuperInterface(InterfaceDecl decl) {
           int idx = -1;
           for(int i = 0; i < getSuperInterfaceIdList().getNumChild(); i++){
               if(((TypeAccess)getSuperInterfaceId(i)).decl().equals(decl)){
                   idx = i;
               }
           }
           if(idx!= -1)
               getSuperInterfaceIdList().removeChild(idx);
       }

  void TypeDecl.replaceTypeAccessInList(Access oldAccess, Access newAccess, List<Access> list){
    if(!oldAccess.isTypeAccess() || !newAccess.isTypeAccess())
      throw new Error("Both access should be type access !");
    TypeDecl oldDecl = ((TypeAccess)oldAccess).decl();
    TypeDecl newDecl = ((TypeAccess)newAccess).decl();

    boolean containsNewAccess = false;
    Access oldAccess0 = null;

    for(Access acc : list){
      if(((TypeAccess)acc).decl().equals(newDecl))
        containsNewAccess = true;

      if(((TypeAccess)acc).decl().equals(oldDecl))
        oldAccess0 = acc;
    }

    if(containsNewAccess)
      list.removeChild(oldAccess0);
    else
      replace(oldAccess0).with(newAccess);

  }

 public void ClassDecl.replaceImplements(Access oldAccess, Access newAccess){
       replaceTypeAccessInList(oldAccess, newAccess, getImplementsList());
  }

 public void InterfaceDecl.replaceSuperInterface(Access oldAccess, Access newAccess){
    replaceTypeAccessInList(oldAccess, newAccess, getSuperInterfaceIds());
  }


  public void Program.printCodeInDirectory(File dir) throws IOException {

    for(CompilationUnit cu : getCompilationUnits()){

      if(cu.fromSource()) {
        String relativePath = cu.getPackageDecl().replace('.', File.separatorChar);

        File f = new File(dir + File.separator +
          relativePath + File.separator + cu.getID() + ".java");

        f.getParentFile().mkdirs();
        BufferedWriter writer = new BufferedWriter(new FileWriter(f));
        writer.write(cu.toString());
        writer.close();
      }
    }
  }

	//scala compiler does not like ASTNode type parameter bound
	public CompilationUnit Program.insertUnusedType(String path, String pkg, TypeDecl td) {
       return insertUnusedType(path, pkg, new List<ImportDecl>(), td);
    }

    public static MethodDecl MethodDecl.createAbstractMethod(Access returnType, String name, ParameterDeclaration[] params){
      List<ParameterDeclaration> paramList = new List<ParameterDeclaration>();
      for(ParameterDeclaration p : params){
          paramList.add(p);
      }
      return new MethodDecl(new Modifiers("public", "abstract"), returnType, name, paramList, new List<Access>(), new Opt());
  	}

  	public MethodDecl ConstructorDecl.createConstructorMethod(String name){                                                                               
         List<ParameterDeclaration> params = this.getParameterList().copy();                                                               
         List<Expr> args = new List<Expr>();                                                                                               
         for(int i =0; i< params.getNumChild(); i++)                                                                                       
             args.add(params.getChild(i).createLockedAccess());                                                                            
                                                                                                                                           
         return new MethodDecl(new Modifiers("public"),                                                                                    
                 this.hostType().createLockedAccess(),                                                                                     
                 name, params, new List<Access>(),                                                                                         
                 new Opt<Block>(new Block(new ReturnStmt( new ClassInstanceExpr(hostType().createLockedAccess(), args)))));                
                                                                                                                                           
     }


    /*
    syn boolean Access.isPrimitiveTypeAccess();
    eq Access.isPrimitiveTypeAccess() = false;
    eq PrimitiveTypeAccess.isPrimitiveTypeAccess() = true;


    public void ASTNode.replaceTypeAccess(Access oldUsee, Access newUsee){
      for(int i = 0; i < getNumChild(); i++)
          getChild(i).replaceTypeAccess(oldUsee, newUsee);
  	}

    public boolean TypeAccess.sameDeclAs(Access access){
        return access.isPrimitiveTypeAccess()
            && decl().equals(((PrimitiveTypeAccess)access).decl())
            || access.isTypeAccess()
            && this.decl().equals(((TypeAccess)access).decl());
    }

  	public void TypeAccess.replaceTypeAccess(Access oldUsee, Access newUsee){
        if(sameDeclAs(oldUsee))
            replace(this).with(newUsee);
    }
     */

	public void ASTNode.replaceTypeAccess(Access oldUsee, Access newUsee){
      for(int i = 0; i < getNumChild(); i++)
          getChild(i).replaceTypeAccess(oldUsee, newUsee);
  	}

/*
    public void PrimitiveTypeAccess.replaceTypeAccess(Access oldUsee, Access newUsee){
        System.out.println("replaceType for primitive type : TODO !!!");
    }
*/

    public void TypeAccess.replaceTypeAccess(Access oldUsee, Access newUsee){

        if( oldUsee.isTypeAccess()
                && this.decl().equals(((TypeAccess)oldUsee).decl())){
            replace(this).with(newUsee);
        }
    }




  //stop propagation
  public void ClassInstanceExpr.replaceTypeAccess(Access oldUsee, Access newUsee){

        /*System.out.println("****************************************************");
        System.out.println("****************************************************");
        System.out.println("****************************************************");
        System.out.println();


        System.out.println(this + " stop propagation of replaceTypeAccess("+oldUsee+", "+newUsee+")");
        System.out.println(" getAccess() instanceof ParTypeAccess = " + (getAccess() instanceof ParTypeAccess));
        for(int i=0; i<getNumChild(); i++){
            System.out.println("child "+ i + " : " + getChild(i).getClass() + " = " + getChild(i).getClass());

        }*/

        if( getAccess() instanceof ParTypeAccess){
            List<Access> typeArgs =  ((ParTypeAccess) getAccess()).getTypeArguments();
            for(int i = 0; i<typeArgs.getNumChild(); i++){
                typeArgs.getChild(i).replaceTypeAccess(oldUsee, newUsee);
            }
            //parTypeAccess.getTypeArguments().replaceTypeAccess(oldUsee, newUsee);
        }
        getArgList().replaceTypeAccess(oldUsee, newUsee);
        getTypeDeclOpt().replaceTypeAccess(oldUsee, newUsee);
    }


  public void ASTNode.replaceMethodCall(MethodDecl oldUsed, MethodDecl newUsed){
      for(int i = 0; i < getNumChild(); i++)
          getChild(i).replaceMethodCall(oldUsed, newUsed);
  } 

  public void MethodAccess.replaceMethodCall(MethodDecl oldUsed, MethodDecl newUsed){
      if(this.decl() == oldUsed)
        replace(this).with(new MethodAccess(newUsed.name(), this.getArgList()));
  }


  public void ASTNode.replaceByConstructorMethodCall(MethodDecl cm){
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).replaceByConstructorMethodCall(cm);
    }

  private int MethodDecl.uidSeed = 0;
  public ParameterDeclaration MethodDecl.introduceParameter(TypeDecl typeCreated, String suffix){
        //TODO make code ok for generic type !
        Collection<ConstructorDecl> ctors = typeCreated.constructors();
        ConstructorDecl noArgsCtor = null;
        for(ConstructorDecl ctor : ctors){
            if(ctor.getParameterList().getNumChild() == 0)
                noArgsCtor= ctor;
        }
        if(noArgsCtor == null)
            throw new Error("no parameterless constructor for class " + typeCreated.fullName());

        ParameterDeclaration newParameter =
                new ParameterDeclaration(new Modifiers(),
                        typeCreated.createLockedAccess(),
                        typeCreated.name().toLowerCase() + suffix + uidSeed);
        uidSeed ++;

        addParameter(newParameter);

        for(MethodAccess methodUse : uses())
            methodUse.addArg(new ClassInstanceExpr(typeCreated.createLockedAccess(),  new List<Expr>()));
            return newParameter;
    }
  
  public void ClassInstanceExpr.replaceByConstructorMethodCall(MethodDecl cm){
        if( !(this.hostBodyDecl() instanceof MethodDecl))
            throw new Error("replaceByConstructorMethodCall, this.hostBodyDecl is " +
                    this.hostBodyDecl().getClass() + "does not know what to do !!");

        MethodDecl enclosingMethod = (MethodDecl)this.hostBodyDecl();

        ParameterDeclaration factoryParameter =
                enclosingMethod.introduceParameter(((TypeAccess)this.getAccess()).decl(), "Ktor");

        replace(this).with(new Dot(factoryParameter.createLockedAccess(),
                cm.createBoundAccess(this.getArgs())));

    }

 

  public void ASTNode.puckDelete(){
         getParent().removeChild(this);
     }

  public void TypeDecl.puckDelete(){                                                                                                           
         if(compilationUnit().getNumTypeDecl() == 1)                                                                                       
             compilationUnit().puckDelete();                                                                                             
         else                                                                                                                              
             super.puckDelete();                                                                                                         
     }

  public String Program.getRootPath(){
        CompilationUnit rcu = getCompilationUnit(0);
        int i = 0;
        while(rcu == null && i < getNumCompilationUnit()){
            i++;
            rcu = getCompilationUnit(i);
        }

        if(rcu == null) throw new Error("cannot found rootPath");

        return rcu.getRootPath();
  }

    public void Program.eliminateLockedNamesInSources(){
        //calling eliminateLockedNames from program after calling lockAllNames
        //provoke cause exceptions in the "@primitive package"
        for (CompilationUnit cu : (List<CompilationUnit>)getCompilationUnitList()){
            if(cu.fromSource())
                cu.eliminateLockedNames();
        }
    }
}